## STL Collections
##

snippet scifnd
    #ifndef _${1:NAME}_H_
    #define _$1_H_

    #endif

snippet scinc
    #include "systemc.h"
    #include "${1:`vim_snippets#Filename('$1', 'name')`}.h"

# SystemC module
snippet scmod

    SC_MODULE(${1:`vim_snippets#Filename('$1', 'name')`}){

        ${0:/* data */};

        SC_CTOR($1){

        }
    };

# SystemC class
snippet sccl
    #include "systemc.h"

    class ${1:`vim_snippets#Filename('$1', 'name')`} : public ${2:sc_module} {
    public:
        ${0:/* data */};

        SC_CTOR($1){

        }
    };

# SystemC main
snippet scmain
    int sc_main(int argc, char* argv[]){

        ${0:/* data */};

        sc_start();

        return 0;
    }

# SystemC trace file
# Create VCD trace file
snippet sctrvcd
    sc_trace_file* ${1};
    $1 = sc_create_vcd_trace_file("${2}");
    if (!$2)
        cout << "There was an error."<<endl;
    sc_trace($1, ${3}, "$3");

    sc_start();

    sc_close_vcd_trace_file($1);

snippet   scme
abbr      SC_METHOD( process )
    SC_METHOD( ${1:process} );${0}

snippet   scth
abbr      SC_THREAD( process )
    SC_THREAD( ${1:process} );${0}

# Signals {{{
snippet   scin
abbr      sc_in< data_type > name;
    sc_in <${1:data_types} > ${2:name};${0}

snippet   scout
abbr      sc_out< data_type > name;
    sc_out<${1:data_types} > ${2:name};${0}

snippet   scio
abbr      sc_inout< data_type > name;
    sc_inout<${1:data_types} > ${2:name};${0}
# }}}

snippet sc_fifo
    sc_fifo<${1:element_type}> ${2:name}(${3:size});
    $2.write(${4:value});
    $2.READ(${5:reference});
    $0 = $2.read()
    if($2.nb_read($5)){ // non-blocking

    }

    if($2.num_available() == 0)
        wait($2.data_written_event());
    if($2.num_free() == 0)
        next_trigger($2.data_read_event());
